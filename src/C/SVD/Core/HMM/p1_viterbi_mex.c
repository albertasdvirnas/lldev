#include"p1_viterbi.h"
#include"p1_viterbi_traceback.h"
#include<mex.h>
#include<matrix.h>
#include<string.h>
/*  Input:
 *      p1_profile: Plan-1 profile, generated by p1_build. The profile is a 
 *                  matlab struct with 3 fields: 
 *                  0 - len
 *                      Integer of model length.
 *                  1 - Em
 *                      Struct containing two fields, 
 *                      0 - Mf 
 *                      1 - Mr
 *                  2 - Tr
 *                      Struct containing ten fields.
 *                      0 - Mf
 *                      1 - Mr
 *                      2 - Bf
 *                      3 - Br
 *                      4 - Ef
 *                      5 - Er
 *                      6 - N
 *                      7 - Jf
 *                      8 - Jr
 *                      9 - C
 *
 *      dsequence:  A discretised barcode sequence. Generated by discretise_barcode.
 *  Output:
 *      viterbi_matrices:
 *                  A matlab struct with the following fields:
 *                  MfMX, MrMX, ..etc
*/
#define P1_PROFILE prhs[0]
#define DSEQUENCE prhs[1]
#define TRACEBACK plhs[0]
#define SCORE plhs[1]

void mexFunction( int nlhs, mxArray *plhs[],
                  int nrhs, const mxArray *prhs[])
{
    int *profile_length;
    double *tmpseq;
    int *dsequence, *vtrace;
    int seqlen;
    struct p1_profile profile;
    struct p1_viterbi_matrices output_matrices;    
    if (nrhs!=2)
        mexErrMsgIdAndTxt("SVD:HMM:p1_viterbi",
                          "Two inputs required, a plan-1 profile and a "\
                          "discretised barcode sequence");

    mxArray *mlEm = mxGetFieldByNumber(P1_PROFILE, 0, 1);
    mxArray *mlTr = mxGetFieldByNumber(P1_PROFILE, 0, 2);
    profile.length = mxGetNumberOfElements(mxGetFieldByNumber(mlTr, 0, 2));
    profile.em.Mf = mxGetData(mxGetFieldByNumber(mlEm, 0, 0)); 
    profile.em.Mr = mxGetData(mxGetFieldByNumber(mlEm, 0, 1));
    profile.tr.Mf = mxGetData(mxGetFieldByNumber(mlTr, 0, 0));
    profile.tr.Mr = mxGetData(mxGetFieldByNumber(mlTr, 0, 1));
    profile.tr.Bf = mxGetData(mxGetFieldByNumber(mlTr, 0, 2));
    profile.tr.Br = mxGetData(mxGetFieldByNumber(mlTr, 0, 3));
    profile.tr.Ef = mxGetData(mxGetFieldByNumber(mlTr, 0, 4));
    profile.tr.Er = mxGetData(mxGetFieldByNumber(mlTr, 0, 5));
    profile.tr.N  = mxGetData(mxGetFieldByNumber(mlTr, 0, 6));
    profile.tr.Jf = mxGetData(mxGetFieldByNumber(mlTr, 0, 7));
    profile.tr.Jr = mxGetData(mxGetFieldByNumber(mlTr, 0, 8));
    profile.tr.C  = mxGetData(mxGetFieldByNumber(mlTr, 0, 9));
    
    seqlen = mxGetNumberOfElements(DSEQUENCE);
    tmpseq = mxGetPr(DSEQUENCE);
    /* dsequence contains the sequence length as its first element */
    dsequence = malloc((1 + seqlen) * sizeof(int)); 
    dsequence[0] = seqlen;
    int i;
    for(i=0;i<seqlen;i++){
        dsequence[i+1] = tmpseq[i];
    }
     
    output_matrices = p1_gen_vmtx(profile.length, seqlen);
    output_matrices = viterbi(profile, dsequence, output_matrices);
    vtrace = mxCalloc(seqlen * 3, sizeof(int));
    
    p1_viterbi_traceback(output_matrices, profile, dsequence, vtrace);

    TRACEBACK = mxCreateNumericMatrix(0, 0, mxINT32_CLASS, mxREAL);
    
    mxSetData(TRACEBACK, vtrace);
    mxSetM(TRACEBACK, seqlen);
    mxSetN(TRACEBACK, 3);

    SCORE = mxCreateDoubleScalar(output_matrices.score);

    free(dsequence);
    p1_free_vmtx(output_matrices);
    return;
}
