function [ noOfFeatures, peakFeatureLabels ] = ...
    assign_peak_labels(peakLocs, peakHeights , localWindowRadius)
    
    %
    % Takes a sets of peak positions at different times 
    % and returns feature labels (1,2,3...) to each peak.
    %
    % Features are generated by calculating links (one-to-one)
    % between peaks in row i and i+1. 
    % The link criteria are based on minimum-score-between-peaks criterion:
    %   score =   abs(distance between peaks) + [ 1 - exp(-dI )]
    % where
    %   dI = abs(intensity of peak in row i - intensity of peak 
    %           in row i+1)/abs(intensity of peak in row i)
    % The peak pair with the smallest score is linked first, 
    % then second best pair (with non-used peaks), etc.
    %
    % Input:
    % 
    % peakLocs = cell array with peak positions at different times
    % peakHeights = cell array with peak intensities at different times
    % localWindowRadius = we connect two peaks in row i and row i+1
    %                     only if their distance is <= localWindowRadius
    %
    % Output:
    %
    % noOfFeatures  = number of features
    % peakFeatureLabels = cell array of the same size as peakLocs. Here we
    %                     output the feature label (1,2,...) for each peak
    %
    % Written by Tobias AmbjÃ¶rnsson
    %
    
    import ELD.Processing.find_all_pairs;
   
    noOfFeatures = length(peakLocs{1});
    peakFeatureLabels{1} = 1:noOfFeatures; % peak feature labels for first row
    
    % Loop over all time frames
    for i=1:length(peakLocs)-1
      
        
        %
        % Generate a sorted list (according to score) with 
        % all allowed parent-child combinations
        %
        parentsPeakPos = peakLocs{i};
        childrenPeakPos = peakLocs{i+1}; 
        
        % generate list with indices for all potential pairs
        allPairsList = find_all_pairs( parentsPeakPos, ...
                                childrenPeakPos , localWindowRadius);
        [temp , noOfPairs] = size( allPairsList);
        
        
        % Distance scores 
        distanceScores = abs( childrenPeakPos(allPairsList(2,:)) ... 
                               - parentsPeakPos(allPairsList(1,:)) );
        
        % Normalized intensity difference scores
        parentsPeakHeightsTemp = peakHeights{i};
        childrenPeakHeightsTemp = peakHeights{i+1};
        parentsPeakHeights=parentsPeakHeightsTemp(allPairsList(1,:));
        childrenPeakHeights=childrenPeakHeightsTemp(allPairsList(2,:));
        intDiffScores = abs(parentsPeakHeights - childrenPeakHeights)./abs(parentsPeakHeights);
        intDiffScores = 1 - exp(-intDiffScores); % gives a number between 0 and 1.
        
        % Total score
        totalScore = distanceScores + intDiffScores;
        
        % Sort according to score   
        [vals , idxSorted] = sort(totalScore);
        allPairsListSorted = allPairsList(:,idxSorted);
  
        
         %
         % Now, assign parent-child links based on the 
         % smallest-scores-first criterion
         % Make sure there is a one-to-one correspondence 
         % between children and parents.
         %
         assignedParents = zeros(1,length(parentsPeakPos));
         assignedChildren = zeros(1,length(childrenPeakPos));
         noOfSelectedPairs = min(length(parentsPeakPos), length(childrenPeakPos));
         selectedParents = zeros(1,noOfSelectedPairs);
         selectedChildren = zeros(1,noOfSelectedPairs);
         counterSelectedPairs = 1;
         idx = 1;
         while idx <= noOfPairs & counterSelectedPairs <= length(parentsPeakPos) ... 
                 & counterSelectedPairs <= length(childrenPeakPos)
             
             parentIdx = allPairsListSorted(1,idx);
             childIdx = allPairsListSorted(2,idx);
             if assignedParents(parentIdx)==0 & assignedChildren(childIdx)==0 
                  assignedParents(parentIdx)=1;
                  assignedChildren(childIdx)=1;
                  selectedParents(counterSelectedPairs) = allPairsListSorted(1,idx);
                  selectedChildren(counterSelectedPairs) = allPairsListSorted(2,idx);
                  counterSelectedPairs = counterSelectedPairs + 1;  
                
             end
             idx = idx + 1;
             
         end        
         % Trim off unselected parents/children
         noOfSelectedPairs = counterSelectedPairs-1;
         selectedParents = selectedParents(1:noOfSelectedPairs);
         selectedChildren = selectedChildren(1:noOfSelectedPairs);
          
         
         %
         % Assign feature labels to the children
         %
         % If a child is linked to a parent, let the child 
         % inherit feature label from parent     
         peakLabelsParents = peakFeatureLabels{i};
         peakLabelsChildren = zeros(1,length(peakLocs{i+1}));
         peakLabelsTemp = peakLabelsParents(selectedParents);
         peakLabelsChildren(selectedChildren) = peakLabelsTemp;
         peakFeatureLabels{i+1} = peakLabelsChildren;   
         % For children without a parent, start new feature(s)
         unassignedIdx = find(assignedChildren == 0);
         for counter = 1:length(unassignedIdx)
             noOfFeatures = noOfFeatures + 1;
             peakLabelsChildren(unassignedIdx(counter)) = noOfFeatures;
         end
         peakFeatureLabels{i+1} = peakLabelsChildren;
         
         
                 
    end
        
    
         

end

