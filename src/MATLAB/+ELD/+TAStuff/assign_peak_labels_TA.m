function [ noOfFeatures peakFeatureLabels ] = ...
    assign_peak_labels_TA(peakLocs, peakHeights , localWindowRadius, allowCrossings)
    
    %
    % Takes a sets of peak positions at different times 
    % and returns feature labels (1,2,3...) to each peak.
    % Depending on the input, features are allowed to cross or not.
    %
    % Features are generated by calculating links (one-to-one)
    % between peaks in row i and i+1. 
    % The link criteria are based on minimum-score-between-peaks criterion:
    %   score =   abs(distance between peaks) + [ 1 - exp(-dI )]
    % where
    %   dI = abs(intensity of peak in row i - intensity of peak 
    %           in row i+1)/abs(intensity of peak in row i)
    % The peak pair with the smallest score is linked first, 
    % then second best pair (with non-used peaks), etc.
    % No new link which crosses a previously chosen link is accepted
    % if allowCrossings = false.
    %
    % Input:
    % 
    % peakLocs = cell array with peak positions at different times
    % peakHeights = cell array with peak intensities at different times
    % localWindowRadius = we connect two peaks in row i and row i+1
    %                     only if their distance is <= localWindowRadius
    % allowCrossings = set equal to 1 (true) if features are allowed to cross,
    %                  else set equal to 0 (false)
    %
    % Output:
    %
    % noOfFeatures  = number of features
    % peakFeatureLabels = cell array of the same size as peakLocs. Here we
    %                     output the feature label (1,2,...) for each peak
    %
    % Written by Tobias AmbjÃ¶rnsson
    %
    
    import ELD.TAStuff.find_all_pairs_TA;
    import ELD.TAStuff.find_in_sorted_vector;
   
    noOfFeatures = length(peakLocs{1});
    peakFeatureLabels{1} = 1:noOfFeatures; % peak feature labels for first row
    
    % Loop over all time frames
    for i=1:length(peakLocs)-1
      
        %
        % Generate a sorted list (according to score) with 
        % all allowed parent-child combinations
        %
        parentsPeakPos = peakLocs{i};
        childrenPeakPos = peakLocs{i+1}; 
        
        % generate list with indices for all potential pairs
        allPairsList = find_all_pairs_TA( parentsPeakPos, ...
                                childrenPeakPos , localWindowRadius);
        [temp , noOfPairs] = size( allPairsList);
        
        
        % Distance scores 
        distanceScores = abs( childrenPeakPos(allPairsList(2,:)) ... 
                               - parentsPeakPos(allPairsList(1,:)) );
        
        % Normalized intensity difference scores
        parentsPeakHeightsTemp = peakHeights{i};
        childrenPeakHeightsTemp = peakHeights{i+1};
        parentsPeakHeights=parentsPeakHeightsTemp(allPairsList(1,:));
        childrenPeakHeights=childrenPeakHeightsTemp(allPairsList(2,:));
        intDiffScores = abs(parentsPeakHeights - childrenPeakHeights)./abs(parentsPeakHeights);
        intDiffScores = 1 - exp(-intDiffScores); % gives a number between 0 and 1.
        
        % Total score
        totalScore = distanceScores + intDiffScores;
        
        % Sort according to score   
        [vals , idxSorted] = sort(totalScore);
        allPairsListSorted = allPairsList(:,idxSorted);
  
        
         %
         % Now, assign parent-child links based on the 
         % smallest-scores-first criterion
         %
         % Make sure there is a one-to-one correspondence 
         % between children and parents.
         %
         % Also make sure there are no crossings of features
         % (if: allowedCrossings = false).
         % To achieve this, we keep the list selectedParents
         % sorted throughout the procedure below. We then check that 
         % the proposed children peak position
         % and the proposed parent peak positions would (if chosen) 
         % ends up in the same index in the two sorted vectors above.
         % This guarantees no feature crossings.
             
         assignedParents = zeros(1,length(parentsPeakPos));
         assignedChildren = zeros(1,length(childrenPeakPos));
         noOfSelectedPairs = min(length(parentsPeakPos), length(childrenPeakPos));
         selectedParents = (length(parentsPeakPos)+1)*ones(1,noOfSelectedPairs);
                              % Initialize values larger than the valid range
         selectedChildren = (length(childrenPeakPos)+1)*ones(1,noOfSelectedPairs);
         counterSelectedPairs = 0;
         idx = 1;
         % Go through the all pairs list
         while idx <= noOfPairs & counterSelectedPairs <= length(parentsPeakPos) ... 
                 & counterSelectedPairs <= length(childrenPeakPos)
             
             parentIdx = allPairsListSorted(1,idx);
             childIdx = allPairsListSorted(2,idx);
             
             idxInSelectedParents = find_in_sorted_vector(selectedParents,parentIdx);
             idxInSelectedChild = find_in_sorted_vector(selectedChildren,childIdx);
             
             nonCrossingPair = (idxInSelectedParents == idxInSelectedChild);
                  
             if assignedParents(parentIdx)==0 & assignedChildren(childIdx)==0 ...
                 & (allowCrossings | nonCrossingPair)
             
                  counterSelectedPairs = counterSelectedPairs + 1; 
                 
                  assignedParents(parentIdx)=1;
                  assignedChildren(childIdx)=1;
                  
                  % insert so that selectedParents remain sorted at all
                  % steps
                  selectedParents(idxInSelectedParents+1:counterSelectedPairs) = ...
                      selectedParents(idxInSelectedParents:counterSelectedPairs-1);
                  selectedParents(idxInSelectedParents) = parentIdx;
                  
                  selectedChildren(idxInSelectedParents+1:counterSelectedPairs) = ...
                      selectedChildren(idxInSelectedParents:counterSelectedPairs-1);
                  selectedChildren(idxInSelectedParents) = childIdx;
                  
                
             end
             idx = idx + 1;
             
            
         end        
         % Trim off unselected parents/children
         noOfSelectedPairs = counterSelectedPairs;
         selectedParents = selectedParents(1:noOfSelectedPairs);
         selectedChildren = selectedChildren(1:noOfSelectedPairs);
          
         
         %
         % Assign feature labels to the children
         %
         % If a child is linked to a parent, let the child 
         % inherit feature label from parent     
         peakLabelsParents = peakFeatureLabels{i};
         peakLabelsChildren = zeros(1,length(peakLocs{i+1}));
         peakLabelsTemp = peakLabelsParents(selectedParents);
         peakLabelsChildren(selectedChildren) = peakLabelsTemp;
         peakFeatureLabels{i+1} = peakLabelsChildren;   
         % For children without a parent, start new feature(s)
         unassignedIdx = find(assignedChildren == 0);
         for counter = 1:length(unassignedIdx)
             noOfFeatures = noOfFeatures + 1;
             peakLabelsChildren(unassignedIdx(counter)) = noOfFeatures;
         end
         peakFeatureLabels{i+1} = peakLabelsChildren;
         
         
                 
    end
        
    
         

end

