function [ result ] = run_least_squares_error_min(numPeaksToFit, scaleFactor, areaOnePeak, areaOnePeakStd, confidenceInterval, xIdxStart, xIdxEnd, experimentalValues, sigma, areaOnePeakScaled, meanBackgroundNoise)
    % Here the solver 'lsqnonlin' is run under 'Multistart'
    % The constraints in the parameters are also set here
    % The area parameters are scaled to be of the same order of the positions
    % Input:   'numPeaksToFit' (number of peaks to fit)
    % Output:  'result' vector (solution of the least-squares problem, positions in the first half, areas in the second)
    import ELF.Core.calculate_error;

    min_mu = zeros(1, numPeaksToFit) + xIdxStart;
    min_A = zeros(1, numPeaksToFit) + ((areaOnePeak - (confidenceInterval * areaOnePeakStd)) / areaOnePeak);
    max_mu = zeros(1, numPeaksToFit) + xIdxEnd;
    max_A = zeros(1, numPeaksToFit) + ((areaOnePeak + (confidenceInterval * areaOnePeakStd)) / areaOnePeak);
    iniPositGuess = (xIdxEnd - xIdxStart + 1) * (((1:numPeaksToFit) - 1) / numPeaksToFit) + xIdxStart;
    iniAreaGuess = min_A(1) + (rand(1,numPeaksToFit) * (max_A(1) - min_A(1)));
    ms = MultiStart( ...
        'Display', 'off', ...
        'StartPointsToRun', 'bounds', ...
        'TolFun', sum((0.01 * experimentalValues).^2), ...
        'TolX', 0.001);
    x0 = [iniPositGuess, scaleFactor*iniAreaGuess];
    lb = [min_mu, scaleFactor*min_A];
    ub = [max_mu, scaleFactor*max_A];
    xIdxs = (xIdxStart:xIdxEnd);
    problem = createOptimProblem(...
        'lsqnonlin', ...
        'x0', x0, ...
        'objective', @(peakParams) (calculate_error(peakParams(1:(end/2)), peakParams(((end/2) + 1):end), xIdxs, experimentalValues, sigma, areaOnePeakScaled, meanBackgroundNoise)), ...
        'lb', lb, ...
        'ub', ub, ...
        'xdata', xIdxs, ...
        'ydata', experimentalValues);
    result = run(ms, problem, round((xIdxEnd - xIdxStart) * numPeaksToFit / 3)) ;
end
     
     
